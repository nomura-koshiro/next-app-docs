# RFC 9457: Problem Details for HTTP APIs

このプロジェクトは、エラーレスポンスに [RFC 9457 (Problem Details for HTTP APIs)](https://www.rfc-editor.org/rfc/rfc9457.html) を採用しています。RFC 9457は、HTTP APIのエラーレスポンスを標準化し、クライアントが一貫した方法でエラーを処理できるようにする仕様です。

## 概要

RFC 9457は、エラー情報を構造化された形式で提供するための標準を定義しています。これにより、以下のメリットが得られます：

- **一貫性**: 全てのエラーレスポンスが同じ構造を持つ
- **拡張性**: 標準フィールドに加えて、カスタムフィールドを追加可能
- **タイプセーフ**: エラータイプをURIで識別することで、型安全なエラー処理が可能
- **自己記述的**: エラーレスポンス自体が十分な情報を含む

## Problem Detailsの構造

RFC 9457のエラーレスポンスは、以下の標準フィールドを持ちます：

```typescript
{
  type: string;      // エラータイプを識別するURI（必須ではないが推奨）
  title: string;     // 人間が読める短い説明
  status: number;    // HTTPステータスコード
  detail: string;    // 詳細な説明
  instance?: string; // このエラーが発生した特定のリソースURI（オプション）
  [key: string]: unknown; // 拡張フィールド
}
```

### Content-Type

RFC 9457準拠のエラーレスポンスは、以下のContent-Typeヘッダーを使用します：

```http
Content-Type: application/problem+json
```

## 実装例

### サーバー側（MSWハンドラー）

```typescript
// 404 Not Found
return HttpResponse.json(
  {
    type: "https://api.example.com/problems/resource-not-found",
    title: "Resource Not Found",
    status: 404,
    detail: "The requested user does not exist",
    instance: `/api/v1/users/${userId}`,
  },
  {
    status: 404,
    headers: { "Content-Type": "application/problem+json" },
  }
);

// 401 Unauthorized
return HttpResponse.json(
  {
    type: "https://api.example.com/problems/unauthorized",
    title: "Unauthorized",
    status: 401,
    detail: "The provided credentials are invalid",
    instance: "/api/v1/auth/login",
  },
  {
    status: 401,
    headers: { "Content-Type": "application/problem+json" },
  }
);

// 409 Conflict
return HttpResponse.json(
  {
    type: "https://api.example.com/problems/duplicate-resource",
    title: "Duplicate Resource",
    status: 409,
    detail: "User is already a member of this project",
    instance: `/api/v1/projects/${projectId}/members`,
  },
  {
    status: 409,
    headers: { "Content-Type": "application/problem+json" },
  }
);
```

### バリデーションエラーの拡張フィールド

バリデーションエラーの場合、標準フィールドに加えて`errors`フィールドを使用します：

```typescript
return HttpResponse.json(
  {
    type: "https://api.example.com/problems/validation-error",
    title: "Validation Failed",
    status: 422,
    detail: "The request data failed validation",
    instance: "/api/v1/users",
    errors: {  // 拡張フィールド
      email: ["メールアドレスはすでに使用されています"],
      name: ["名前は必須です"],
      age: ["年齢は0以上でなければなりません"]
    }
  },
  {
    status: 422,
    headers: { "Content-Type": "application/problem+json" },
  }
);
```

## クライアント側の実装

### ApiErrorクラス

クライアント側では、`ApiError`クラスがRFC 9457のエラーレスポンスをラップします：

```typescript
import { ApiError, ProblemTypes } from "@/lib/api-client";

try {
  await apiClient.post("/api/v1/users", userData);
} catch (error) {
  if (error instanceof ApiError) {
    // RFC 9457フィールドへのアクセス
    console.log(error.type);     // エラータイプURI
    console.log(error.title);    // タイトル
    console.log(error.status);   // ステータスコード
    console.log(error.detail);   // 詳細説明
    console.log(error.instance); // リソースURI

    // タイプチェック
    if (error.isType(ProblemTypes.VALIDATION_ERROR)) {
      const validationErrors = error.getExtension("errors");
      console.log("バリデーションエラー:", validationErrors);
    }

    // ステータスコードチェック
    if (error.isClientError()) {
      // 4xxエラーの処理
    } else if (error.isServerError()) {
      // 5xxエラーの処理
    }
  }
}
```

### ProblemTypesの定義

プロジェクトで使用する標準的なエラータイプは、`src/lib/api-client.ts`で定義されています：

```typescript
export const ProblemTypes = {
  // 認証エラー
  UNAUTHORIZED: "https://api.example.com/problems/unauthorized",
  FORBIDDEN: "https://api.example.com/problems/forbidden",
  TOKEN_EXPIRED: "https://api.example.com/problems/token-expired",

  // バリデーションエラー
  VALIDATION_ERROR: "https://api.example.com/problems/validation-error",
  INVALID_REQUEST: "https://api.example.com/problems/invalid-request",

  // ビジネスロジックエラー
  RESOURCE_NOT_FOUND: "https://api.example.com/problems/resource-not-found",
  DUPLICATE_RESOURCE: "https://api.example.com/problems/duplicate-resource",
  INSUFFICIENT_CREDIT: "https://api.example.com/problems/insufficient-credit",

  // サーバーエラー
  INTERNAL_SERVER_ERROR: "https://api.example.com/problems/internal-server-error",
  SERVICE_UNAVAILABLE: "https://api.example.com/problems/service-unavailable",

  // デフォルト
  ABOUT_BLANK: "about:blank",
};
```

## エラーハンドリングのベストプラクティス

### 1. エラータイプによる分岐

```typescript
const handleApiError = (error: unknown) => {
  if (!(error instanceof ApiError)) {
    console.error("予期しないエラー:", error);
    return;
  }

  switch (error.type) {
    case ProblemTypes.UNAUTHORIZED:
      // 認証エラー → ログインページへリダイレクト
      router.push("/login");
      break;

    case ProblemTypes.VALIDATION_ERROR:
      // バリデーションエラー → フォームにエラー表示
      const errors = error.getExtension<Record<string, string[]>>("errors");
      setFormErrors(errors);
      break;

    case ProblemTypes.RESOURCE_NOT_FOUND:
      // リソースが見つからない → 404ページへ
      router.push("/404");
      break;

    default:
      // その他のエラー → 汎用エラーメッセージ
      toast.error(error.detail || "エラーが発生しました");
  }
};
```

### 2. React Query との統合

```typescript
const { mutate } = useMutation({
  mutationFn: (data) => apiClient.post("/api/v1/users", data),
  onError: (error) => {
    if (error instanceof ApiError) {
      if (error.isType(ProblemTypes.VALIDATION_ERROR)) {
        const validationErrors = error.getExtension("errors");
        // フォームにエラーを表示
        Object.entries(validationErrors).forEach(([field, messages]) => {
          setError(field, { message: messages[0] });
        });
      } else {
        toast.error(error.detail);
      }
    }
  },
});
```

### 3. カスタムフックでの利用

```typescript
export const useApiErrorHandler = () => {
  const router = useRouter();

  return useCallback((error: unknown) => {
    if (!(error instanceof ApiError)) return;

    // クライアントエラー (4xx)
    if (error.isClientError()) {
      if (error.status === 401) {
        router.push("/login");
      } else if (error.status === 403) {
        toast.error("アクセス権限がありません");
      } else if (error.status === 404) {
        router.push("/404");
      } else {
        toast.error(error.detail);
      }
    }

    // サーバーエラー (5xx)
    if (error.isServerError()) {
      toast.error("サーバーエラーが発生しました");
      // エラーログをサーバーに送信
      logErrorToServer(error.toJSON());
    }
  }, [router]);
};
```

## リトライ戦略

TanStack Queryは、エラータイプに基づいて適切なリトライ戦略を自動的に適用します：

```typescript
// src/lib/tanstack-query.ts
retry: (failureCount, error) => {
  if (error instanceof ApiError) {
    // クライアントエラー (4xx) はリトライしない
    if (error.isClientError()) {
      return false;
    }
    // サーバーエラー (5xx) は最大3回リトライ
    return failureCount < 3;
  }
  return failureCount < 3;
}
```

## テスト

### MSWでのエラーレスポンスのテスト

```typescript
import { http, HttpResponse } from "msw";
import { ProblemTypes } from "@/lib/api-client";

const handlers = [
  http.post("*/api/v1/users", () => {
    return HttpResponse.json(
      {
        type: ProblemTypes.VALIDATION_ERROR,
        title: "Validation Failed",
        status: 422,
        detail: "The request data failed validation",
        instance: "/api/v1/users",
        errors: {
          email: ["メールアドレスはすでに使用されています"],
        },
      },
      {
        status: 422,
        headers: { "Content-Type": "application/problem+json" },
      }
    );
  }),
];
```

### ApiErrorクラスのテスト

```typescript
import { ApiError, ProblemTypes } from "@/lib/api-client";

describe("ApiError", () => {
  it("RFC 9457フィールドを正しく抽出する", () => {
    const problemDetails = {
      type: ProblemTypes.RESOURCE_NOT_FOUND,
      title: "Resource Not Found",
      status: 404,
      detail: "User not found",
      instance: "/api/v1/users/123",
    };

    const error = new ApiError({
      response: { data: problemDetails, status: 404 },
    } as any);

    expect(error.type).toBe(ProblemTypes.RESOURCE_NOT_FOUND);
    expect(error.title).toBe("Resource Not Found");
    expect(error.status).toBe(404);
    expect(error.detail).toBe("User not found");
    expect(error.instance).toBe("/api/v1/users/123");
  });

  it("拡張フィールドを取得できる", () => {
    const problemDetails = {
      type: ProblemTypes.VALIDATION_ERROR,
      status: 422,
      errors: { email: ["Invalid email"] },
    };

    const error = new ApiError({
      response: { data: problemDetails, status: 422 },
    } as any);

    const errors = error.getExtension("errors");
    expect(errors).toEqual({ email: ["Invalid email"] });
  });
});
```

## 参考資料

- [RFC 9457: Problem Details for HTTP APIs](https://www.rfc-editor.org/rfc/rfc9457.html)
- [RFC 9457 公式仕様書（日本語訳）](https://tex2e.github.io/rfc-translater/html/rfc9457.html)
- [API Client実装ガイド](./06-api-client.md)
- [エラーハンドリングルール](../04-development/01-coding-standards/09-error-handling-rules.md)
